(ns clj-arsenal.check
  (:require
    [clj-arsenal.basis :as b])
  (:host-ns
    [clj-arsenal.basis.macro-common :as macro-common]))

(defmacro samps
  [gen-key & {:as gen-opts}]
  (binding [macro-common/*expand-host* :cljd]
    (macro-common/expand-samps gen-key gen-opts)))

(defmacro samp
  [gen-key & {:as gen-opts}]
  (binding [macro-common/*expand-host* :cljd]
    (macro-common/expand-samp gen-key gen-opts)))

(defonce ^:macro-support !check-funs (atom #{}))

(defmacro check
  [check-key & body]
  (when (macro-common/check-ns? (str *ns*))
    (binding [macro-common/*expand-host* :cljd]
      (let [check-fn-name (gensym (str "check-" (namespace check-key) "-" (name check-key)))
            check-fn-ns (ns-name *ns*)]
        (swap! !check-funs conj (symbol check-fn-ns check-fn-name))
        `(defn ~check-fn-name []
           ~(macro-common/expand-check check-key body))))))

(defmacro when-check
  [& body]
  (when (macro-common/check-ns? (str *ns*))
    `(do ~@body)))

(defmacro run
  []
  `(do
     ~@(map
         (fn [fun-sym]
           `(~fun-sym))
         @!check-funs)))

(defn expect
  [f & args]
  (when-not (apply f args)
    (throw
      (b/err
        :id ::expectation-unsatisfied
        :msg "Expectation Unsatisfied"
        ::expect-fun (str f)
        ::expect-args args))))
